const t=t=>{const s="[object "+t+"]";return function(t){return e(t)===s}},e=t=>Object.prototype.toString.call(t),s=t=>t instanceof Date?t.getTime():n(t)?t.map(s):t&&"function"==typeof t.toJSON?t.toJSON():t,n=t("Array"),r=t("Object"),i=t("Function"),o=(t,e)=>{if(null==t&&t==e)return!0;if(t===e)return!0;if(Object.prototype.toString.call(t)!==Object.prototype.toString.call(e))return!1;if(n(t)){if(t.length!==e.length)return!1;for(let s=0,{length:n}=t;s<n;s++)if(!o(t[s],e[s]))return!1;return!0}if(r(t)){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(const s in t)if(!o(t[s],e[s]))return!1;return!0}return!1},c=(t,e,s,r,i,o)=>{const h=e[r];if(n(t)&&isNaN(Number(h)))for(let n=0,{length:i}=t;n<i;n++)if(!c(t[n],e,s,r,n,t))return!1;return r===e.length||null==t?s(t,i,o):c(t[h],e,s,r+1,h,t)};class h{constructor(t,e,s){this.params=t,this.owneryQuery=e,this.options=s,this.init()}init(){}reset(){this.done=!1,this.success=!1}}class u extends h{constructor(t,e,s,n){super(t,e,s),this._children=n}reset(){this.success=!1,this.done=!1;for(let t=0,{length:e}=this._children;t<e;t++)this._children[t].reset()}childrenNext(t,e,s){let n=!0,r=!0;for(let i=0,{length:o}=this._children;i<o;i++){const o=this._children[i];if(o.next(t,e,s),o.success||(r=!1),o.done){if(!o.success)break}else n=!1}this.done=n,this.success=r}}class a extends u{next(t,e,s){this.childrenNext(t,e,s)}}class l extends u{constructor(t,e,s,n,r){super(e,s,n,r),this.keyPath=t,this._nextNestedValue=(t,e,s)=>(this.childrenNext(t,e,s),!this.done)}next(t,e,s){c(t,this.keyPath,this._nextNestedValue,0,e,s)}}const p=(t,e)=>{if(t instanceof Function)return t;if(t instanceof RegExp)return e=>"string"==typeof e&&t.test(e);const n=s(t);return t=>e(n,s(t))};class d extends h{init(){this._test=p(this.params,this.options.compare)}next(t,e,s){this._test(t,e,s)&&(this.done=!0,this.success=!0)}}const f=(t,e,s)=>new d(t,e,s);class x extends h{next(){this.done=!0,this.success=!1}}const w=t=>{return e=(e,n,r)=>{const i=typeof s(e),o=t(e);return new d(t=>typeof s(t)===i&&o(t),n,r)},(t,s,n)=>null==t?new x(t,s,n):e(t,s,n);var e},y=(t,e,s,n)=>{const r=n.operations[t];if(!r)throw new Error("Unsupported operation: "+t);return r(e,s,n)},_=t=>{for(const e in t)if("$"===e.charAt(0))return!0;return!1},g=(t,e,s,n)=>{if(_(e)){const[r,i]=O(e,n);if(i.length)throw new Error("Property queries must contain only operations, or exact objects.");return new l(t,e,s,n,r)}return new l(t,e,s,n,[new d(e,s,n)])},m=(t,e,s)=>{const[n,r]=O(t,s),i=[];return n.length&&i.push(new l([],t,e,s,n)),i.push(...r),1===i.length?i[0]:new a(t,e,s,i)},O=(t,e)=>{const s=[],n=[];if(!(r=t)||r.constructor!==Object&&r.constructor!==Array&&"function Object() { [native code] }"!==r.constructor.toString()&&"function Array() { [native code] }"!==r.constructor.toString()||r.toJSON)return s.push(new d(t,t,e)),[s,n];var r;for(const r in t)if("$"===r.charAt(0)){const n=y(r,t[r],t,e);null!=n&&s.push(n)}else n.push(g(r.split("."),t[r],t,e));return[s,n]},$=(t,{compare:e,operations:s}={})=>{const n=m(t,null,{compare:e||o,operations:Object.assign({},s||{})});return(t,e,s)=>(n.reset(),n.next(t,e,s),n.success)};class b extends h{init(){this._test=p(this.params,this.options.compare)}reset(){super.reset(),this.success=!0}next(t){this._test(t)&&(this.done=!0,this.success=!1)}}class j extends h{init(){this._queryOperation=m(this.params,this.owneryQuery,this.options)}reset(){this._queryOperation.reset()}next(t,e,s){this._queryOperation.reset(),n(s)?(this._queryOperation.next(t,e,s),this.done=this._queryOperation.done||e===s.length-1,this.success=this._queryOperation.success):(this.done=!0,this.success=!1)}}class q extends h{init(){this._queryOperation=m(this.params,this.owneryQuery,this.options)}reset(){this._queryOperation.reset()}next(t,e,s){this._queryOperation.next(t,e,s),this.done=this._queryOperation.done,this.success=!this._queryOperation.success}}class N extends h{init(){this._ops=this.params.map(t=>m(t,null,this.options))}reset(){this.done=!1,this.success=!1;for(let t=0,{length:e}=this._ops;t<e;t++)this._ops[t].reset()}next(t,e,s){let n=!1,r=!1;for(let i=0,{length:o}=this._ops;i<o;i++){const o=this._ops[i];if(o.next(t,e,s),o.success){n=!0,r=o.success;break}}this.success=r,this.done=n}}class S extends N{next(t,e,s){super.next(t,e,s),this.success=!this.success}}class E extends h{init(){this._testers=this.params.map(t=>{if(_(t))throw new Error("cannot nest $ under "+this.constructor.name.toLowerCase());return p(t,this.options.compare)})}next(t,e,s){let n=!1,r=!1;for(let e=0,{length:s}=this._testers;e<s;e++){if((0,this._testers[e])(t)){n=!0,r=!0;break}}this.success=r,this.done=n}}class k extends E{next(t,e,s){super.next(t,e,s),this.success=!this.success}}class v extends h{next(t,e,s){s.hasOwnProperty(e)===this.params&&(this.done=!0,this.success=!0)}}class A extends u{constructor(t,e,s){super(t,e,s,t.map(t=>m(t,e,s)))}next(t,e,s){this.childrenNext(t,e,s)}}const P=(t,e,s)=>new d(t,e,s),C=(t,e,s)=>new b(t,e,s),F=(t,e,s)=>new N(t,e,s),J=(t,e,s)=>new S(t,e,s),Q=(t,e,s)=>new j(t,e,s),z=(t,e,s)=>new k(t,e,s),D=(t,e,s)=>new E(t,e,s),L=w(t=>e=>e<t),R=w(t=>e=>e<=t),V=w(t=>e=>e>t),B=w(t=>e=>e>=t),I=([t,e],n,r)=>new d(n=>s(n)%t===e,n,r),M=(t,e,s)=>new v(t,e,s),T=(t,e,s)=>new d(new RegExp(t,e.$options),e,s),U=(t,e,s)=>new q(t,e,s),G=(t,e,s)=>new d(e=>null!=e&&(e instanceof t||e.constructor===t),e,s),H=(t,e,s)=>new A(t,e,s),K=H,W=(t,e,s)=>new d(e=>e&&e.length===t,e,s),X=()=>null,Y=(t,e,s)=>{let n;if(i(t))n=t;else{if(process.env.CSP_ENABLED)throw new Error('In CSP mode, sift does not support strings in "$where" condition');n=new Function("obj","return "+t)}return new d(t=>n.bind(t)(t),e,s)};var Z=Object.freeze({__proto__:null,$eq:P,$ne:C,$or:F,$nor:J,$elemMatch:Q,$nin:z,$in:D,$lt:L,$lte:R,$gt:V,$gte:B,$mod:I,$exists:M,$regex:T,$not:U,$type:G,$and:H,$all:K,$size:W,$options:X,$where:Y});export default(t,{compare:e,operations:s}={})=>$(t,{compare:e,operations:Object.assign({},Z,s)});export{K as $all,H as $and,Q as $elemMatch,P as $eq,M as $exists,V as $gt,B as $gte,D as $in,L as $lt,R as $lte,I as $mod,C as $ne,z as $nin,J as $nor,U as $not,X as $options,F as $or,T as $regex,W as $size,G as $type,Y as $where,d as EqualsOperation,f as createEqualsOperation,$ as createQueryTester};
